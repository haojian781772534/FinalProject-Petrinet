/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Sat Nov 28 2020 22:21:18 GMT-0600 (北美中部标准时间).
 */

define([
    'js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames'
], function (
    CONSTANTS,
    GMEConcepts,
    nodePropertyNames
) {

    'use strict';

    function MyVisualizerControl(options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;


        this._widget = options.widget;

        this._currentNodeId = null;
        this._currentNodeParentId = undefined;

        this._initWidgetEventHandlers();

        this._logger.debug('ctor finished');
    }

    MyVisualizerControl.prototype._initWidgetEventHandlers = function () {
        this._widget.onNodeClick = function (id) {
            // Change the current active object
            WebGMEGlobal.State.registerActiveObject(id);
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    MyVisualizerControl.prototype.selectedObjectChanged = function (nodeId) {
        var desc = this._getObjectDescriptor(nodeId),
            self = this;
        self._logger.debug('activeObject nodeId \'' + nodeId + '\'');

        if (self._currentNodeId) {
            self._client.removeUI(self._territoryId);
        }

        self._currentNodeId = nodeId;
        self._currentNodeParentId = undefined;

        if (typeof self._currentNodeId === 'string') {
            self._selfPatterns = {};
            self._selfPatterns[nodeId] = {children: 0};  // Territory "rule"

            self._widget.setTitle(desc.name.toUpperCase());

            if (typeof desc.parentId === 'string') {
                self.$btnModelHierarchyUp.show();
            } else {
                self.$btnModelHierarchyUp.hide();
            }

            self._currentNodeParentId = desc.parentId;

            self._territoryId = self._client.addUI(self, function (events) {
                self._eventCallback(events);
            });

            self._client.updateTerritory(self._territoryId, self._selfPatterns);

            self._selfPatterns[nodeId] = {children: 1};
            self._client.updateTerritory(self._territoryId, self._selfPatterns);
        }


        runPluginOnServer(self);
        setTimeout(()=>{console.info(self._client._pluginMessage);console.info(self._client._nums);
                        self._widget.initNetwork(self._client._nums,self._client._pluginMessage);},3000);
    };



    // This next function retrieves the relevant node information for the widget
    MyVisualizerControl.prototype._getObjectDescriptor = function (nodeId) {
        var node = this._client.getNode(nodeId),
            objDescriptor;
        if (node) {
            objDescriptor = {
                id: node.getId(),
                name: node.getAttribute(nodePropertyNames.Attributes.name),
                childrenIds: node.getChildrenIds(),
                parentId: node.getParentId(),
                isConnection: GMEConcepts.isConnection(nodeId)
            };
        }

        return objDescriptor;
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    MyVisualizerControl.prototype._eventCallback = function (events) {
        var i = events ? events.length : 0,
            event;

        this._logger.debug('_eventCallback \'' + i + '\' items');

        while (i--) {
            event = events[i];
            switch (event.etype) {

            case CONSTANTS.TERRITORY_EVENT_LOAD:
                this._onLoad(event.eid);
                break;
            case CONSTANTS.TERRITORY_EVENT_UPDATE:
                this._onUpdate(event.eid);
                break;
            case CONSTANTS.TERRITORY_EVENT_UNLOAD:
                this._onUnload(event.eid);
                break;
            default:
                break;
            }
        }

        this._logger.debug('_eventCallback \'' + events.length + '\' items - DONE');
    };

    MyVisualizerControl.prototype._onLoad = function (gmeId) {
        var description = this._getObjectDescriptor(gmeId);
        this._widget.addNode(description);
    };

    MyVisualizerControl.prototype._onUpdate = function (gmeId) {
        var description = this._getObjectDescriptor(gmeId);
        this._widget.updateNode(description);
    };

    MyVisualizerControl.prototype._onUnload = function (gmeId) {
        this._widget.removeNode(gmeId);
    };

    MyVisualizerControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {

        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    MyVisualizerControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    MyVisualizerControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    MyVisualizerControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    MyVisualizerControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
        }
    };

    MyVisualizerControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    MyVisualizerControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    MyVisualizerControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    MyVisualizerControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };


        const runPluginOnServer = function (pself) {
            var myContext = pself._client.getCurrentPluginContext('ModelicaCodeGenerator'),
                pluginMessage = [],
                nums = [],
                classifier = [];
            pself._client.runServerPlugin('ModelicaCodeGenerator', myContext, function (err_object, raw_message) {
                let num_split = raw_message.messages[0].message.split(" ");
                for (let j = 0; j < num_split.length; j++) {
                    nums.push(parseInt(num_split[j]));
                }
                for (let i = 1; i < eval(nums.join("+")) + 1; i++) {
                    pluginMessage.push(raw_message.messages[i].message);
                }

                let classifier_split = raw_message.messages[eval(nums.join("+")) + 1].message.split(" ");
                for (let j = 0; j < classifier_split.length; j++) {
                    classifier.push(parseInt(classifier_split[j]));
                }

            });
            setTimeout(()=>{pself._client._pluginMessage=pluginMessage;pself._client._nums=nums;pself._client._classifier=classifier},1000);
        };

    MyVisualizerControl.prototype._initializeToolbar = function () {
        var self = this,
            toolBar = WebGMEGlobal.Toolbar;

        this._toolbarItems = [];

        this._toolbarItems.push(toolBar.addSeparator());

        /************** Go to hierarchical parent button ****************/
        this.$btnModelHierarchyUp = toolBar.addButton({
            title: 'Go to parent',
            icon: 'glyphicon glyphicon-circle-arrow-up',
            clickFn: function (/*data*/) {
                WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
            }
        });
        this._toolbarItems.push(this.$btnModelHierarchyUp);
        this.$btnModelHierarchyUp.hide();

        var pthis = this;
        this.$btnModelReset = toolBar.addButton({
            title: 'Reset the model',
            icon: 'glyphicon glyphicon-stop',
            clickFn: function () {
                pthis._widget._initialize();
                pthis._widget.initNetwork(pthis._client._nums,pthis._client._pluginMessage);
            }
        });
        this._toolbarItems.push(this.$btnModelReset);


        const classes = ['(1) Free-choice petri net', '(2) State machine', '(3) Marked graph', '(4) Workflow net'];
        this._toolbarInitialized = true;
        this.$btnModelClassify = toolBar.addButton({
            title: 'Classify the model',
            icon: 'glyphicon glyphicon-ok',
            clickFn: function () {
                if (eval(self._client._classifier.join("+")) === 0) {
                    //alert("This petri net does not belong to any of those four categories");
                } else {
                    let alert_info = "This petri net falls in the following category/categories:";
                    for (let j = 0; j < classes.length; j++) {
                        if (pthis._client._classifier[j] === 1) {
                            alert_info = alert_info.concat("\n",classes[j]);
                        }
                    }
                    //alert(alert_info);
                }
            }
        });
        this._toolbarItems.push(this.$btnModelClassify);
    };

    return MyVisualizerControl;
});
